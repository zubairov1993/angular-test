import { Injectable, inject } from "@angular/core";

import { QuestionI } from "../interfaces/questions.interface"
import { BehaviorSubject, Observable } from "rxjs";
import { AuthService } from "src/app/auth/services/auth.service";
import { environment } from "src/environments/environment";
import { HttpClient } from "@angular/common/http";

@Injectable({ providedIn: 'root' })
export class QuestionService {
  private authService = inject(AuthService);
  private http = inject(HttpClient);

  public questionsData$: BehaviorSubject<QuestionI[]> = new BehaviorSubject<QuestionI[]>([]);

  data: QuestionI[] = [
    {
      question: "В чем отличие фреймворка от библиотеки (приведите примеры и отличия)?",
      level: "junior",
      isCompleted: false,
      index: 1,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Фреймворк предоставляет готовую структуру приложения, в то время как библиотека предоставляет набор инструментов.", isCorrect: true },
        { isSelect: false, answer: "Фреймворк и библиотека - это синонимы и могут использоваться взаимозаменяемо.", isCorrect: false },
        { isSelect: false, answer: "Библиотеки предоставляют только графические элементы, а фреймворки - логику приложения.", isCorrect: false },
        { isSelect: false, answer: "Фреймворк - это стиль программирования, а библиотека - это набор готовых компонентов.", isCorrect: false },
      ],
    },
    {
      question: "Какие популярные CSS, JS библиотеки вы знаете?",
      level: "junior",
      isCompleted: false,
      index: 2,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "jQuery, Bootstrap, React", isCorrect: false },
        { isSelect: false, answer: "Lodash, Express, SASS", isCorrect: false },
        { isSelect: false, answer: "Angular, Vue, React", isCorrect: true },
        { isSelect: false, answer: "Redux, D3.js, Stylus", isCorrect: false },
      ],
    },
    {
      question: "Знаете ли вы как браузер обрабатывает index.html (расскажите про Critical Rendering Path)?",
      level: "junior",
      isCompleted: false,
      index: 3,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Браузер загружает index.html параллельно с другими ресурсами и затем отображает страницу.", isCorrect: false },
        { isSelect: false, answer: "Critical Rendering Path - это алгоритм, который браузер использует для рендеринга важных элементов страницы.", isCorrect: true },
        { isSelect: false, answer: "Браузер загружает index.html синхронно перед загрузкой других ресурсов.", isCorrect: false },
        { isSelect: false, answer: "Critical Rendering Path - это путь к файлу index.html на сервере.", isCorrect: false },
      ],
    },
    {
      question: "Какие типы данных есть в JavaScript?",
      level: "junior",
      isCompleted: false,
      index: 4,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "String, Number, Boolean, Array, Object", isCorrect: true },
        { isSelect: false, answer: "Text, Integer, Float, List, Dictionary", isCorrect: false },
        { isSelect: false, answer: "HTML, CSS, JSON, XML", isCorrect: false },
        { isSelect: false, answer: "Character, Integer, Decimal, Collection, Map", isCorrect: false },
      ],
    },
    {
      question: "Как устроена память в JavaScript (memory heap, memory stack)?",
      level: "junior",
      isCompleted: false,
      index: 5,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "В JavaScript есть только memory heap, где хранятся все данные и объекты.", isCorrect: false },
        { isSelect: false, answer: "Memory stack используется для хранения данных, а memory heap - для выполнения кода.", isCorrect: false },
        { isSelect: false, answer: "Memory heap - это место, где хранятся объекты и данные, а memory stack - стек вызовов функций.", isCorrect: true },
        { isSelect: false, answer: "Memory stack и memory heap - это синонимы и могут использоваться взаимозаменяемо.", isCorrect: false },
      ],
    },
    {
      question: "Что такое this и расскажите про область видимости?",
      level: "junior",
      isCompleted: false,
      index: 6,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "this - это ключевое слово, которое всегда ссылается на глобальный объект в JavaScript.", isCorrect: false },
        { isSelect: false, answer: "this - это ключевое слово, которое ссылается на объект, в контексте которого оно вызвано.", isCorrect: true },
        { isSelect: false, answer: "Область видимости - это место, где хранятся переменные и функции в JavaScript.", isCorrect: false },
        { isSelect: false, answer: "this - это ключевое слово, которое используется для создания новых переменных в области видимости.", isCorrect: false },
      ],
    },
    {
      question: "В чем отличие var от const, let?",
      level: "junior",
      isCompleted: false,
      index: 7,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "var - это ключевое слово для объявления констант, а let и const - для переменных.", isCorrect: false },
        { isSelect: false, answer: "var создает лексическую область видимости, в то время как let и const - блочную.", isCorrect: false },
        { isSelect: false, answer: "const - это ключевое слово для объявления констант, которые нельзя изменять, а let - для объявления переменных с блочной областью видимости.", isCorrect: true },
        { isSelect: false, answer: "let - это ключевое слово для объявления констант, а var - для переменных.", isCorrect: false },
      ],
    },
    {
      question: "Объясните, как работает наследование прототипов, что такое цепочка прототипов, и когда появилось ключевое слово class в JS?",
      level: "junior",
      isCompleted: false,
      index: 8,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Наследование прототипов - это механизм, при котором объект может наследовать свойства и методы другого объекта, образуя цепочку прототипов. Ключевое слово class появилось в JavaScript в ES6.", isCorrect: true },
        { isSelect: false, answer: "Цепочка прототипов - это механизм, при котором объекты могут образовывать цепь друг за другом, чтобы наследовать их свойства. Ключевое слово class появилось в JavaScript в ES5.", isCorrect: false },
        { isSelect: false, answer: "Наследование прототипов - это механизм, при котором объекты наследуют только методы, но не свойства. Ключевое слово class появилось в JavaScript в ES7.", isCorrect: false },
        { isSelect: false, answer: "Цепочка прототипов - это механизм, при котором объекты образуют кольцевую структуру, чтобы наследовать свойства друг друга. Ключевое слово class появилось в JavaScript в ES4.", isCorrect: false },
      ],
    },
    {
      question: "Что такое структура данных и какие виды вы знаете (Стек, etc)?",
      level: "junior",
      isCompleted: false,
      index: 9,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Структура данных - это способ организации и хранения данных, и включает в себя такие виды, как стек, очередь, хэш-таблица и деревья.", isCorrect: true },
        { isSelect: false, answer: "Структура данных - это способ организации и хранения данных, и включает в себя только один вид - массив.", isCorrect: false },
        { isSelect: false, answer: "Структура данных - это способ организации и хранения данных, и включает в себя только один вид - объект.", isCorrect: false },
        { isSelect: false, answer: "Структура данных - это способ организации и хранения данных, и включает в себя только один вид - строку.", isCorrect: false },
      ],
    },
    {
      question: "Что такое Promise и для чего используется в JS?",
      level: "junior",
      isCompleted: false,
      index: 10,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Promise - это ключевое слово для объявления переменных в JavaScript. Оно используется для создания асинхронных функций.", isCorrect: false },
        { isSelect: false, answer: "Promise - это способ обработки ошибок в JavaScript. Он используется для отлова исключений в коде.", isCorrect: false },
        { isSelect: false, answer: "Promise - это объект, представляющий результат асинхронной операции. Он используется для управления асинхронными задачами и обработки их результата.", isCorrect: true },
        { isSelect: false, answer: "Promise - это ключевое слово для создания циклов в JavaScript. Он используется для выполнения повторяющихся задач.", isCorrect: false },
      ],
    },
    {
      question: "Что такое call-stack, task-queue (приведите примеры работы)?",
      level: "junior",
      isCompleted: false,
      index: 11,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Call-stack - это структура данных, представляющая собой стек вызова функций. Task-queue - это очередь асинхронных задач.", isCorrect: false },
        { isSelect: false, answer: "Call-stack - это структура данных для управления вызовами функций в JavaScript. Task-queue - это очередь асинхронных задач, ожидающих выполнения.", isCorrect: true },
        { isSelect: false, answer: "Call-stack - это механизм для выполнения синхронного кода, task-queue - для асинхронного.", isCorrect: false },
        { isSelect: false, answer: "Call-stack и task-queue - это одно и то же, просто разные названия для одного механизма в JavaScript.", isCorrect: false },
      ],
    },
    {
      question: "Что такое макро и микро задачи в JS?",
      level: "junior",
      isCompleted: false,
      index: 12,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Макро задачи - это задачи с большой вычислительной сложностью, микро задачи - с малой. Это позволяет разделять задачи на более и менее ресурсоемкие.", isCorrect: false },
        { isSelect: false, answer: "Макро и микро задачи - это понятия, связанные с механизмом Event Loop в JavaScript. Микрозадачи (microtasks) выполняются перед следующим циклом событий, а макрозадачи (macrotasks) - после него.", isCorrect: true },
        { isSelect: false, answer: "Макро задачи - это задачи, выполняющиеся быстро, микро задачи - медленно. Это помогает оптимизировать производительность кода.", isCorrect: false },
        { isSelect: false, answer: "Макро и микро задачи - это абстрактные понятия, не применимые к JavaScript.", isCorrect: false },
      ],
    },
    {
      question: "Назовите основные принципы ООП?",
      level: "junior",
      isCompleted: false,
      index: 13,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Основные принципы ООП включают в себя инкапсуляцию, наследование и полиморфизм. Инкапсуляция позволяет скрыть детали реализации, наследование позволяет создавать новые классы на основе существующих, а полиморфизм позволяет объектам одного типа вести себя по-разному.", isCorrect: true },
        { isSelect: false, answer: "Основные принципы ООП включают в себя цикличность, взаимодействие и абстракцию. Цикличность означает, что объекты могут ссылаться друг на друга, взаимодействие - обмен сообщениями, а абстракция - создание абстрактных классов.", isCorrect: false },
        { isSelect: false, answer: "Основные принципы ООП включают в себя структуру, абстракцию и модульность. Структура определяет, как объекты взаимодействуют, а абстракция - создание абстрактных классов для обобщения общих свойств и методов. Модульность позволяет разделить код на независимые модули.", isCorrect: false },
        { isSelect: false, answer: "Основные принципы ООП включают в себя определение типов, рефакторинг и компоновку. Определение типов - это создание классов и интерфейсов, рефакторинг - улучшение структуры кода, а компоновка - объединение классов в приложении.", isCorrect: false },
      ],
    },
    {
      question: "Что такое класс и интерфейс?",
      level: "junior",
      isCompleted: false,
      index: 14,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Класс - это шаблон для создания объектов. Интерфейс - это абстрактное описание свойств и методов, которые класс должен реализовать.", isCorrect: true },
        { isSelect: false, answer: "Класс - это совокупность данных, а интерфейс - способ взаимодействия с этими данными.", isCorrect: false },
        { isSelect: false, answer: "Класс - это абстрактное описание свойств и методов, а интерфейс - шаблон для создания объектов.", isCorrect: false },
        { isSelect: false, answer: "Класс и интерфейс - это синонимы в объектно-ориентированном программировании.", isCorrect: false },
      ],
    },
    {
      question: "Что такое конструктор класса?",
      level: "junior",
      isCompleted: false,
      index: 15,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Конструктор класса - это специальный метод, который вызывается при создании объекта этого класса. Он инициализирует свойства объекта и может принимать аргументы.", isCorrect: true },
        { isSelect: false, answer: "Конструктор класса - это метод, который используется для уничтожения объектов класса.", isCorrect: false },
        { isSelect: false, answer: "Конструктор класса - это статический метод, который вызывается без создания объекта.", isCorrect: false },
        { isSelect: false, answer: "Конструктор класса - это специальный метод для клонирования объектов класса.", isCorrect: false },
      ],
    },
    {
      question: "Расскажите про стек TCP/IP, а также более подробно про, что такое HTTP и какую роль он играет при разработке приложений?",
      level: "junior",
      isCompleted: false,
      index: 16,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Сетевая модель TCP/IP включает в себя четыре уровня: прикладной, транспортный, сетевой и канальный. HTTP - протокол прикладного уровня, используется для передачи данных между клиентом и сервером. Он играет ключевую роль в веб-разработке, позволяя загружать веб-страницы, обмениваться данными и выполнять запросы к серверу.", isCorrect: true },
        { isSelect: false, answer: "Сетевая модель TCP/IP включает в себя три уровня: физический, канальный и сетевой. HTTP - это часть сетевого уровня и не играет существенной роли в веб-разработке.", isCorrect: false },
        { isSelect: false, answer: "Сетевая модель TCP/IP включает в себя пять уровней: физический, канальный, сетевой, транспортный и прикладной. HTTP - протокол транспортного уровня, используется для обеспечения надежной передачи данных.", isCorrect: false },
        { isSelect: false, answer: "Сетевая модель TCP/IP не имеет уровней. HTTP - это спецификация для передачи данных в сети.", isCorrect: false },
      ],
    },
    {
      question: "Что такое REST API, как происходит взаимодействие (расскажите про основные коды ошибок, заголовки пакетов и способы их отправки)?",
      level: "junior",
      isCompleted: false,
      index: 17,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "REST API - это стиль архитектуры для разработки сетевых приложений. Взаимодействие осуществляется через HTTP-методы, такие как GET, POST, PUT и DELETE. Основные коды ошибок включают 404 (Not Found), 500 (Internal Server Error) и 401 (Unauthorized). Заголовки пакетов содержат информацию о запросе и ответе, например, Content-Type и Authorization. Способы отправки данных могут включать JSON и XML.", isCorrect: true },
        { isSelect: false, answer: "REST API - это протокол для передачи данных по сети. Взаимодействие осуществляется через TCP-пакеты. Основные коды ошибок - 200 (OK), 302 (Found) и 304 (Not Modified). Заголовки пакетов определяют порт и IP-адрес сервера. Способы отправки данных - это бинарные потоки данных.", isCorrect: false },
        { isSelect: false, answer: "REST API - это стандарт для обмена информацией в локальных сетях. Взаимодействие происходит через USB-подключение. Основные коды ошибок - 100 (Continue), 201 (Created) и 204 (No Content). Заголовки пакетов - это физические адреса устройств. Способы отправки данных - это модуляция сигнала.", isCorrect: false },
        { isSelect: false, answer: "REST API - это структура данных для хранения информации. Взаимодействие осуществляется через SQL-запросы. Основные коды ошибок - 401 (Unauthorized), 403 (Forbidden) и 503 (Service Unavailable). Заголовки пакетов - это названия полей в таблицах. Способы отправки данных - это записи в базе данных.", isCorrect: false },
      ],
    },
    {
      question: "Зачем нам нужны определения типов, где есть JavaScript с динамической типизацией?",
      level: "junior",
      isCompleted: false,
      index: 18,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Определения типов (TypeScript, Flow) нужны для улучшения надежности и читаемости кода в JavaScript с динамической типизацией. Они позволяют статически проверять типы данных, предотвращая ошибки во время выполнения. Это упрощает разработку и обеспечивает более надежный код.", isCorrect: true },
        { isSelect: false, answer: "Определения типов не нужны в JavaScript, так как язык имеет динамическую типизацию и может автоматически определять типы данных во время выполнения.", isCorrect: false },
        { isSelect: false, answer: "Определения типов используются только для статически типизированных языков, и в JavaScript они бесполезны.", isCorrect: false },
        { isSelect: false, answer: "Определения типов нужны только для серверной части приложения, а не для фронтенда на JavaScript.", isCorrect: false },
      ],
    },
    {
      question: "Что такое пользовательский тип данных?",
      level: "junior",
      isCompleted: false,
      index: 19,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Пользовательский тип данных - это тип данных, созданный разработчиком на основе базовых типов языка программирования. Это позволяет описывать собственные структуры данных, например, объекты или классы.", isCorrect: true },
        { isSelect: false, answer: "Пользовательский тип данных - это данные, введенные пользователем в приложении, например, текстовые сообщения или изображения.", isCorrect: false },
        { isSelect: false, answer: "Пользовательский тип данных - это тип данных, который может быть использован только определенным пользователем, но не в других частях приложения.", isCorrect: false },
        { isSelect: false, answer: "Пользовательский тип данных - это специфичный тип, используемый для хранения информации о пользователях в базе данных.", isCorrect: false },
      ],
    },
    {
      question: "Что такое Union Type (тип объединения) и для чего используется?",
      level: "junior",
      isCompleted: false,
      index: 20,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Union Type - это тип данных, который позволяет объединять несколько других типов данных. Он используется, когда переменная или параметр может иметь несколько возможных типов. Например, можно объявить переменную с типом 'number | string', что означает, что она может содержать число или строку.", isCorrect: true },
        { isSelect: false, answer: "Union Type - это тип данных, который используется для объединения нескольких значений в одно. Например, можно объединить несколько чисел в массив с этим типом.", isCorrect: false },
        { isSelect: false, answer: "Union Type - это тип данных, предназначенный для работы с объединенными сущностями в базе данных. Например, объединение данных о пользователях и заказах.", isCorrect: false },
        { isSelect: false, answer: "Union Type - это специфический тип данных, который используется только в функциях для объединения результатов выполнения нескольких операций.", isCorrect: false },
      ],
    },
    {
      question: "Поддерживает ли TypeScript перегрузку методов?",
      level: "middle",
      isCompleted: false,
      index: 21,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Да, TypeScript поддерживает перегрузку методов. Это позволяет иметь несколько определений одного метода с разными параметрами и возвращаемыми типами.", isCorrect: true },
        { isSelect: false, answer: "Нет, TypeScript не поддерживает перегрузку методов. Все методы должны иметь уникальные имена.", isCorrect: false },
        { isSelect: false, answer: "Перегрузка методов возможна только в JavaScript, но не в TypeScript.", isCorrect: false },
        { isSelect: false, answer: "TypeScript поддерживает перегрузку методов, но только в строгом режиме.", isCorrect: false },
      ],
    },
    {
      question: "Возможна ли перегрузка конструктора в TypeScript?",
      level: "middle",
      isCompleted: false,
      index: 22,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Да, TypeScript позволяет перегрузку конструкторов классов. Вы можете иметь разные наборы параметров для конструктора с разными типами аргументов.", isCorrect: true },
        { isSelect: false, answer: "Нет, в TypeScript перегрузка конструктора недоступна. Конструктор должен иметь фиксированный набор параметров.", isCorrect: false },
        { isSelect: false, answer: "Перегрузка конструктора возможна только для встроенных классов, но не для пользовательских.", isCorrect: false },
        { isSelect: false, answer: "В TypeScript перегрузка конструктора поддерживается только при использовании библиотеки ts-toolbelt.", isCorrect: false },
      ],
    },
    {
      question: "Поддерживает ли TypeScript перегрузку методов (конструкторов)?",
      level: "middle",
      isCompleted: false,
      index: 23,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Да, TypeScript поддерживает перегрузку как методов, так и конструкторов. Это позволяет иметь разные наборы параметров и типов для одного метода или конструктора.", isCorrect: true },
        { isSelect: false, answer: "Нет, TypeScript не поддерживает перегрузку методов или конструкторов. Все методы и конструкторы должны иметь уникальные сигнатуры.", isCorrect: false },
        { isSelect: false, answer: "Перегрузка методов и конструкторов доступна только в JavaScript, но не в TypeScript.", isCorrect: false },
        { isSelect: false, answer: "TypeScript поддерживает перегрузку, но только для методов, не для конструкторов.", isCorrect: false },
      ],
    },
    {
      question: "Что такое декоратор и какие виды декораторов вы знаете?",
      level: "middle",
      isCompleted: false,
      index: 24,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Декоратор - это специальная функция в TypeScript, которая используется для расширения или изменения поведения классов, методов, свойств и других элементов. В Angular, например, декораторы используются для аннотации классов компонентов, сервисов и других элементов приложения. Виды декораторов включают @Component, @Injectable, @ViewChild и многие другие.", isCorrect: true },
        { isSelect: false, answer: "Декоратор - это тип данных в TypeScript, предназначенный для декорирования объектов. Виды декораторов включают @String, @Number, @Boolean и другие.", isCorrect: false },
        { isSelect: false, answer: "Декоратор - это специальная функция, используемая только для тестирования кода. Виды декораторов включают @Test и @Debug.", isCorrect: false },
        { isSelect: false, answer: "Декораторы не используются в TypeScript. Это понятие не существует в данном языке.", isCorrect: false },
      ],
    },
    {
      question: "Что такое Angular?",
      level: "middle",
      isCompleted: false,
      index: 25,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Angular - это платформа и фреймворк для разработки веб-приложений. Он предоставляет набор инструментов для создания клиентских приложений с использованием TypeScript, HTML и CSS. Angular включает в себя модульную структуру, компоненты, инъекцию зависимостей, маршрутизацию и множество других функций.", isCorrect: true },
        { isSelect: false, answer: "Angular - это язык программирования для создания серверных приложений. Он основан на JavaScript и предоставляет возможности для работы с базами данных и серверной логикой.", isCorrect: false },
        { isSelect: false, answer: "Angular - это библиотека для работы с анимациями в веб-разработке. Он предоставляет инструменты для создания анимаций на веб-страницах.", isCorrect: false },
        { isSelect: false, answer: "Angular - это операционная система для мобильных устройств. Он разрабатывается Google и предоставляет платформу для запуска мобильных приложений.", isCorrect: false },
      ],
    },
    {
      question: "В чем разница между AngularJS и Angular?",
      level: "middle",
      isCompleted: false,
      index: 26,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "AngularJS - это первая версия фреймворка Angular, разработанная Google. Он использует JavaScript и имеет архитектуру MVC (Model-View-Controller). Angular - это новая версия фреймворка, известная как Angular 2+ или просто Angular. Он использует TypeScript и предлагает более современную архитектуру с компонентами, инъекцией зависимостей и другими улучшениями.", isCorrect: true },
        { isSelect: false, answer: "AngularJS и Angular - это одно и то же, разные названия одной и той же версии фреймворка.", isCorrect: false },
        { isSelect: false, answer: "AngularJS - это старая версия Angular, предшествующая Angular. Angular - это обновленная версия AngularJS с улучшенной производительностью и новыми функциями.", isCorrect: false },
        { isSelect: false, answer: "AngularJS - это библиотека JavaScript, а Angular - это фреймворк, основанный на TypeScript. Они предназначены для разных типов приложений.", isCorrect: false },
      ],
    },
    {
      question: "Какой должна быть структура каталогов компонентов любого Angular приложения и почему?",
      level: "middle",
      isCompleted: false,
      index: 27,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Структура каталогов компонентов в Angular приложении обычно включает каталоги для компонентов, моделей, сервисов, шаблонов и других ресурсов. Это помогает организовать код и упростить его обслуживание. Каждый компонент имеет свой собственный каталог, что улучшает модульность и понимание структуры приложения.", isCorrect: true },
        { isSelect: false, answer: "Структура каталогов компонентов в Angular приложении не имеет значения, и разработчики могут организовывать ее по своему усмотрению.", isCorrect: false },
        { isSelect: false, answer: "Все компоненты должны размещаться в одном каталоге, чтобы избежать лишних вложенностей.", isCorrect: false },
        { isSelect: false, answer: "Структура каталогов не важна, так как Angular автоматически управляет компонентами и их зависимостями.", isCorrect: false },
      ],
    },
    {
      question: "Что такое MVVM и в чем разница перед MVC?",
      level: "middle",
      isCompleted: false,
      index: 28,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "MVVM (Model-View-ViewModel) и MVC (Model-View-Controller) - это архитектурные паттерны для разработки приложений. Основное различие заключается в том, что MVVM включает в себя ViewModel, который служит для разделения логики представления (View) и модели (Model). В MVC, контроллер (Controller) управляет взаимодействием между моделью и представлением.", isCorrect: true },
        { isSelect: false, answer: "MVVM и MVC - это одно и то же, просто разные названия одного и того же архитектурного паттерна.", isCorrect: false },
        { isSelect: false, answer: "В MVVM нет контроллера, и вся логика управления находится в модели. В MVC, контроллер управляет всем взаимодействием.", isCorrect: false },
        { isSelect: false, answer: "MVVM - это устаревший паттерн, и его редко используют в современных приложениях.", isCorrect: false },
      ],
    },
    {
      question: "Что такое интерполяция в Angular?",
      level: "middle",
      isCompleted: false,
      index: 29,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Интерполяция в Angular - это способ вставки значений переменных из компонента в HTML-шаблон. Она выполняется с помощью двойных фигурных скобок {{ expression }}. Angular автоматически обновляет значения в шаблоне, когда данные в компоненте меняются.", isCorrect: true },
        { isSelect: false, answer: "Интерполяция - это процесс интерпретации текста в коде Angular. Она используется для создания новых выражений внутри приложения.", isCorrect: false },
        { isSelect: false, answer: "Интерполяция - это процесс подключения сторонних библиотек и модулей в Angular приложение.", isCorrect: false },
        { isSelect: false, answer: "Интерполяция - это метод анимации в Angular, позволяющий создавать плавные переходы между состояниями.", isCorrect: false },
      ],
    },
    {
      question: "Какие способы использования шаблонов в Angular вы знаете?",
      level: "middle",
      isCompleted: false,
      index: 30,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "В Angular есть несколько способов использования шаблонов. Основной способ - это использование шаблонов внутри компонентов с помощью HTML и директив Angular. Кроме того, Angular поддерживает шаблоны для маршрутизации, шаблоны для форм, а также возможность создания пользовательских шаблонов и директив.", isCorrect: true },
        { isSelect: false, answer: "Angular не поддерживает шаблоны, и вся разметка должна быть создана программно с использованием JavaScript.", isCorrect: false },
        { isSelect: false, answer: "Шаблоны в Angular можно использовать только для создания статических веб-страниц, но не для динамических приложений.", isCorrect: false },
        { isSelect: false, answer: "Angular использует только один предопределенный шаблон для всех приложений, и его нельзя изменить.", isCorrect: false },
      ],
    },
    {
      question: "В чем разница между структурной и атрибутной директивой, назовите встроенные директивы?",
      level: "middle",
      isCompleted: false,
      index: 31,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Структурная директива изменяет структуру DOM-элементов, добавляя или удаляя элементы. Примеры структурных директив в Angular: *ngIf, *ngFor. Атрибутная директива изменяет атрибуты элементов, например, цвет, стиль, видимость. Примеры атрибутных директив: ngClass, ngStyle.", isCorrect: true },
        { isSelect: false, answer: "Структурная и атрибутная директивы идентичны и могут использоваться взаимозаменяемо.", isCorrect: false },
        { isSelect: false, answer: "В Angular нет структурных директив, только атрибутные.", isCorrect: false },
        { isSelect: false, answer: "Структурные директивы изменяют атрибуты элементов, а атрибутные изменяют структуру DOM.", isCorrect: false },
      ],
    },
    {
      question: "Для чего нужны директивы ng-template, ng-container, ng-content?",
      level: "middle",
      isCompleted: false,
      index: 32,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "ng-template используется для создания шаблонов, которые не будут отображаться в DOM, но могут быть использованы в коде Angular, например, для условий или циклов. ng-container используется для создания логических контейнеров без добавления лишних элементов в DOM. ng-content позволяет внедрять контент внутрь компонентов и директив.", isCorrect: true },
        { isSelect: false, answer: "ng-template, ng-container и ng-content - это просто синонимы, и их можно использовать взаимозаменяемо.", isCorrect: false },
        { isSelect: false, answer: "ng-template используется для вставки контента в DOM, ng-container - для создания шаблонов, а ng-content - для создания контейнеров.", isCorrect: false },
        { isSelect: false, answer: "ng-template, ng-container и ng-content не используются в Angular и являются устаревшими.", isCorrect: false },
      ],
    },
    {
      question: "Что такое директива и как создать собственную?",
      level: "middle",
      isCompleted: false,
      index: 33,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Директива - это инструкция, применяемая к элементам DOM, которая добавляет или изменяет их поведение или вид. Для создания собственной директивы в Angular, вы можете использовать декоратор @Directive. Он должен быть применен к классу директивы и определить ее логику и поведение, а также селектор, который указывает, к каким элементам DOM она будет применяться.", isCorrect: true },
        { isSelect: false, answer: "Директива - это HTML-тег в Angular, и создать собственную директиву можно, просто создав новый HTML-тег.", isCorrect: false },
        { isSelect: false, answer: "Директива - это часть CSS, и ее создание связано с определением стилей элементов.", isCorrect: false },
        { isSelect: false, answer: "Создание собственной директивы в Angular невозможно, можно использовать только встроенные директивы.", isCorrect: false },
      ],
    },
    {
      question: "Что такое директива, компонент, модуль, сервис, пайп в Angular и для чего они нужны?",
      level: "middle",
      isCompleted: false,
      index: 34,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Директива - это инструкция для изменения внешнего вида или поведения элементов DOM. Компонент - это более крупная и независимая часть приложения, объединяющая шаблон, стили и логику. Модуль - это средство организации кода, разбивающее приложение на логические части. Сервис - это класс, предоставляющий общую логику и функциональность для компонентов. Пайп - это инструмент для форматирования данных перед их выводом в шаблон.", isCorrect: true },
        { isSelect: false, answer: "Директива, компонент, модуль, сервис и пайп - это синонимы и могут использоваться взаимозаменяемо.", isCorrect: false },
        { isSelect: false, answer: "Директива - это компонент, модуль - это сервис, а сервис - это пайп. Компонент не имеет определения в Angular.", isCorrect: false },
        { isSelect: false, answer: "Директивы, компоненты, модули, сервисы и пайпы не используются в Angular и не имеют значения.", isCorrect: false },
      ],
    },
    {
      question: "Расскажите об основных параметрах @NgModule, @Component, @Directive, @Injectable, @Pipe.",
      level: "middle",
      isCompleted: false,
      index: 35,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Основные параметры @NgModule включают declarations (список компонентов и директив, определенных в модуле), imports (список импортированных модулей), exports (список экспортируемых компонентов и директив), providers (список сервисов, доступных в модуле). Основные параметры @Component включают selector (селектор элемента DOM), template (HTML-шаблон компонента), styleUrls (список файлов со стилями). Основные параметры @Directive включают selector (селектор элемента DOM, к которому применяется директива). Основные параметры @Injectable включают providedIn (поставщик сервиса). Основные параметры @Pipe включают name (имя пайпа).", isCorrect: true },
        { isSelect: false, answer: "Параметры @NgModule, @Component, @Directive, @Injectable и @Pipe идентичны и могут использоваться взаимозаменяемо.", isCorrect: false },
        { isSelect: false, answer: "В Angular нет параметров для декораторов, все настройки указываются внутри методов классов.", isCorrect: false },
        { isSelect: false, answer: "Параметры @NgModule, @Component, @Directive, @Injectable и @Pipe не используются в Angular и не имеют значения.", isCorrect: false },
      ],
    },
    {
      question: "Что такое динамические компоненты и как их можно использовать в Angular?",
      level: "middle",
      isCompleted: false,
      index: 36,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Динамические компоненты - это компоненты, которые могут быть созданы и отображены во времени выполнения, а не только в статическом шаблоне. Они могут быть использованы для создания динамических интерфейсов, модальных окон, плагинов и других сценариев. Для создания динамических компонентов в Angular можно использовать фабрику компонентов и ViewContainerRef.", isCorrect: true },
        { isSelect: false, answer: "Динамические компоненты - это компоненты, которые могут изменять свои стили и шаблоны в зависимости от пользовательского ввода. Они используются для создания анимаций и интерактивных элементов.", isCorrect: false },
        { isSelect: false, answer: "Angular не поддерживает создание динамических компонентов, все компоненты должны быть определены статически в модуле.", isCorrect: false },
        { isSelect: false, answer: "Динамические компоненты - это компоненты, которые могут быть перетаскиваемыми и изменять свое положение на экране. Они используются для создания сложных пользовательских интерфейсов.", isCorrect: false },
      ],
    },
    {
      question: "Как применить анимацию к компонентам?",
      level: "middle",
      isCompleted: false,
      index: 37,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Анимация в Angular может быть применена с использованием модуля BrowserAnimationsModule. Для создания анимаций можно использовать Angular Animation DSL, который позволяет определить различные состояния и переходы между ними. Анимации могут быть применены к компонентам с использованием директивы [@triggerName], где triggerName - имя анимации.", isCorrect: true },
        { isSelect: false, answer: "Анимации в Angular применяются автоматически к компонентам, и нет необходимости дополнительно настраивать их.", isCorrect: false },
        { isSelect: false, answer: "Анимации в Angular могут быть применены только к HTML-элементам, но не к компонентам.", isCorrect: false },
        { isSelect: false, answer: "Для применения анимации к компонентам в Angular, необходимо написать собственный JavaScript-код для управления анимацией.", isCorrect: false },
      ],
    },
    {
      question: "Объясните механизм загрузки (bootstrap) Angular-приложения в браузере?",
      level: "middle",
      isCompleted: false,
      index: 38,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Механизм загрузки Angular-приложения начинается с загрузки индексного HTML-файла в браузер. Затем браузер загружает скрипт, который содержит основную логику приложения. После загрузки скрипта, Angular приложение инициализируется, создается корневой модуль (NgModule), и вызывается функция platformBrowserDynamic().bootstrapModule(), которая инициирует приложение и начинает его работу.", isCorrect: true },
        { isSelect: false, answer: "Angular-приложение загружается с помощью HTTP-запроса на сервере, и весь код выполняется на сервере, а не в браузере.", isCorrect: false },
        { isSelect: false, answer: "Angular-приложение загружается в браузер сразу после открытия веб-сайта, и нет этапа загрузки скрипта.", isCorrect: false },
        { isSelect: false, answer: "Angular-приложение не загружается в браузере, оно выполняется на сервере, и результаты передаются в браузер в виде статической HTML-страницы.", isCorrect: false },
      ],
    },
    {
      question: "Как происходит взаимодействие компонентов в Angular (опишите components view)?",
      level: "middle",
      isCompleted: false,
      index: 39,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Взаимодействие компонентов в Angular осуществляется с использованием компонентов-родителей и дочерних компонентов. Родительский компонент может передавать данные дочерним компонентам через свойства, а дочерние компоненты могут взаимодействовать с родителем с помощью событий. Для передачи данных между компонентами используются @Input и @Output декораторы.", isCorrect: true },
        { isSelect: false, answer: "В Angular компоненты не взаимодействуют друг с другом, они являются полностью изолированными и независимыми.", isCorrect: false },
        { isSelect: false, answer: "Взаимодействие компонентов в Angular осуществляется только с использованием глобального хранилища данных и событий.", isCorrect: false },
        { isSelect: false, answer: "Взаимодействие компонентов в Angular происходит только через HTTP-запросы к серверу.", isCorrect: false },
      ],
    },
    {
      question: "Каков жизненный цикл у компонентов?",
      level: "middle",
      isCompleted: false,
      index: 40,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Жизненный цикл компонентов в Angular включает такие методы, как ngOnInit (инициализация), ngOnDestroy (уничтожение), ngOnChanges (изменения во входных данных), и другие. Эти методы позволяют выполнять различные действия на разных этапах жизненного цикла компонента, например, инициализацию данных, управление ресурсами и отписку от событий.", isCorrect: true },
        { isSelect: false, answer: "У компонентов в Angular нет жизненного цикла, они работают непрерывно с момента создания до закрытия приложения.", isCorrect: false },
        { isSelect: false, answer: "Жизненный цикл компонентов в Angular включает только один метод - ngOnInit, который вызывается при инициализации компонента.", isCorrect: false },
        { isSelect: false, answer: "Жизненный цикл компонентов в Angular включает методы только для обработки ошибок и исключений.", isCorrect: false },
      ],
    },
    {
      question: "Что такое Shadow DOM и как с ним работать в Angular?",
      level: "middle",
      isCompleted: false,
      index: 41,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Shadow DOM - это механизм веб-компонентов, который позволяет инкапсулировать структуру DOM и стили внутри компонента, изолируя их от внешнего контента. В Angular Shadow DOM используется для создания компонентов с инкапсулированными стилями и элементами. Для работы с Shadow DOM в Angular, вы можете использовать ViewEncapsulation, который определяет, как стили будут применяться к компоненту: внутри Shadow DOM (Emulated), глобально (None) или внутри Shadow DOM с нативным поддержкой (ShadowDom).", isCorrect: true },
        { isSelect: false, answer: "Shadow DOM - это технология, которая не используется в Angular, она применяется только в других фреймворках.", isCorrect: false },
        { isSelect: false, answer: "В Angular нет инструментов для работы с Shadow DOM, все стили и элементы компонента автоматически глобальные и могут взаимодействовать с внешним контентом.", isCorrect: false },
        { isSelect: false, answer: "Shadow DOM - это механизм для создания анимаций в Angular и не имеет отношения к инкапсуляции стилей и элементов.", isCorrect: false },
      ],
    },
    {
      question: "Что такое Data Binding и какие проблемы связанные с ним вы знаете?",
      level: "middle",
      isCompleted: false,
      index: 42,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Data Binding - это механизм связывания данных между моделью и представлением в Angular. Он позволяет автоматически обновлять данные в представлении при изменении модели и наоборот. Проблемы, связанные с Data Binding, включают в себя возможность создания циклических зависимостей (двустороннего связывания), что может привести к непредсказуемому поведению, и потерю производительности при большом количестве связываний.", isCorrect: true },
        { isSelect: false, answer: "Data Binding - это механизм для передачи данных между разными компонентами в Angular, и он не вызывает никаких проблем.", isCorrect: false },
        { isSelect: false, answer: "Data Binding - это механизм для создания анимаций в Angular и не связан с передачей данных.", isCorrect: false },
        { isSelect: false, answer: "Data Binding - это механизм для создания базы данных в Angular.", isCorrect: false },
      ],
    },
    {
      question: "Как вы используете одностороннюю и двухстороннюю привязку данных?",
      level: "middle",
      isCompleted: false,
      index: 43,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Односторонняя привязка данных (one-way data binding) используется для передачи данных из модели в представление (от модели к представлению). Пример: {{ data }}. Двухсторонняя привязка данных (two-way data binding) используется для связи данных между моделью и представлением, так, чтобы изменения в модели могли автоматически обновить представление и наоборот. Пример: [(ngModel)]=\"data\".", isCorrect: true },
        { isSelect: false, answer: "Односторонняя и двухсторонняя привязка данных - это синонимы и используются взаимозаменяемо.", isCorrect: false },
        { isSelect: false, answer: "Односторонняя и двухсторонняя привязка данных - это устаревшие концепции и не используются в Angular.", isCorrect: false },
        { isSelect: false, answer: "Односторонняя и двухсторонняя привязка данных - это механизмы для создания анимаций в Angular.", isCorrect: false },
      ],
    },
    {
      question: "В чем преимущества и недостатки Regular DOM (Angular) перед Virtual DOM (React)?",
      level: "middle",
      isCompleted: false,
      index: 44,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Regular DOM в Angular - это реальное DOM-дерево, которое обновляется при изменении данных. Преимущества включают более низкий порог вхождения, поддержку нативных браузерных событий и хорошую производительность на небольших приложениях. Недостатки - более медленное обновление DOM при большом количестве данных, что может вызвать проблемы с производительностью.", isCorrect: true },
        { isSelect: false, answer: "Virtual DOM (React) всегда лучше, чем Regular DOM (Angular), и не имеет недостатков.", isCorrect: false },
        { isSelect: false, answer: "Regular DOM (Angular) и Virtual DOM (React) - это одно и то же, и нет разницы между ними.", isCorrect: false },
        { isSelect: false, answer: "Regular DOM (Angular) лучше подходит для больших приложений, чем Virtual DOM (React).", isCorrect: false },
      ],
    },
    {
      question: "Что такое ngZone?",
      level: "middle",
      isCompleted: false,
      index: 45,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "NgZone - это сервис в Angular, который позволяет контролировать выполнение кода в зоне (zone). Зона - это контекст выполнения, и ngZone позволяет определить, когде и как выполнять код. Он полезен, например, при выполнении асинхронных операций, чтобы управлять обновлениями представления и обнаруживать изменения. NgZone позволяет управлять процессом обнаружения изменений (change detection) и оптимизировать производительность приложения.", isCorrect: true },
        { isSelect: false, answer: "NgZone - это компонент в Angular, который управляет стилями и представлением компонентов.", isCorrect: false },
        { isSelect: false, answer: "NgZone - это сокращение от 'Next Generation Zone' и не имеет конкретной роли в Angular.", isCorrect: false },
        { isSelect: false, answer: "NgZone - это структура данных для хранения данных в Angular.", isCorrect: false },
      ],
    },
    {
      question: "Как обновлять представление, если ваша модель данных обновляется вне 'зоны'?",
      level: "middle",
      isCompleted: false,
      index: 46,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Если модель данных обновляется вне 'зоны' (за пределами контекста выполнения), то изменения в модели не будут автоматически обнаруживаться Angular и не будут отражены в представлении. Для обновления представления в таких случаях можно использовать метод ApplicationRef.tick(), который позволяет принудительно запустить обнаружение изменений (change detection). Также можно использовать NgZone для управления выполнением кода в нужной зоне.", isCorrect: true },
        { isSelect: false, answer: "Если модель данных обновляется вне 'зоны', это невозможно обработать в Angular, и приложение должно быть перезапущено.", isCorrect: false },
        { isSelect: false, answer: "Модель данных всегда должна обновляться внутри 'зоны', иначе Angular не сможет корректно обновлять представление.", isCorrect: false },
        { isSelect: false, answer: "Для обновления представления вне 'зоны' необходимо использовать JavaScript-функции, Angular не предоставляет для этого инструментов.", isCorrect: false },
      ],
    },
    {
      question: "Что такое EventEmitter и как подписываться на события?",
      level: "middle",
      isCompleted: false,
      index: 47,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "EventEmitter - это класс в Angular, который позволяет создавать и генерировать собственные события в компонентах. Для создания события в компоненте, вы можете объявить новый экземпляр EventEmitter, а затем вызывать его метод emit() для генерации события. Для подписки на события используется метод subscribe(), который позволяет обработать событие в другом компоненте или сервисе.", isCorrect: true },
        { isSelect: false, answer: "EventEmitter - это встроенный браузерный класс для работы с событиями, Angular не использует его.", isCorrect: false },
        { isSelect: false, answer: "В Angular не существует механизма для создания и обработки событий, все события обрабатываются вручную с использованием JavaScript.", isCorrect: false },
        { isSelect: false, answer: "EventEmitter - это специальный декоратор для компонентов, который позволяет им создавать события.", isCorrect: false },
      ],
    },
    {
      question: "Что такое Change Detection, как работает Change Detection Mechanism?",
      level: "middle",
      isCompleted: false,
      index: 48,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Change Detection - это механизм в Angular, который отслеживает изменения в модели данных и обновляет представление при необходимости. Механизм Change Detection работает путем сравнения текущего состояния модели данных с предыдущим состоянием и обновления только измененных частей представления. Это позволяет оптимизировать производительность приложения и уменьшить нагрузку на браузер.", isCorrect: true },
        { isSelect: false, answer: "Change Detection - это процесс изменения структуры DOM-дерева при изменении данных.", isCorrect: false },
        { isSelect: false, answer: "Change Detection - это механизм для создания анимаций в Angular.", isCorrect: false },
        { isSelect: false, answer: "Механизм Change Detection не используется в Angular, представление обновляется непрерывно без проверки изменений в модели данных.", isCorrect: false },
      ],
    },
    {
      question: "Какие существуют стратегии обнаружения изменений?",
      level: "middle",
      isCompleted: false,
      index: 49,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "В Angular существуют две стратегии обнаружения изменений: Default и OnPush. Default - это стратегия, при которой обнаружение изменений выполняется автоматически при изменении любых данных в компоненте. OnPush - это стратегия, при которой обнаружение изменений выполняется только при изменении входных данных (свойств с @Input декоратором) или при вызове метода markForCheck(). Стратегия OnPush может повысить производительность при правильном использовании.", isCorrect: true },
        { isSelect: false, answer: "В Angular существует только одна стратегия обнаружения изменений - Default, и ее нельзя изменить.", isCorrect: false },
        { isSelect: false, answer: "Стратегии обнаружения изменений не существует в Angular, изменения всегда обнаруживаются автоматически.", isCorrect: false },
        { isSelect: false, answer: "В Angular существует только одна стратегия обнаружения изменений - OnPush, и ее нельзя изменить.", isCorrect: false },
      ],
    },
    {
      question: "Сколько Change Detector(ов) может быть во всем приложении?",
      level: "middle",
      isCompleted: false,
      index: 50,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Во всем приложении может быть только один экземпляр главного Change Detector. Этот Change Detector отвечает за обнаружение изменений в корневом компоненте приложения и запуск обнаружения изменений во всем приложении.", isCorrect: true },
        { isSelect: false, answer: "Во всем приложении может быть несколько экземпляров Change Detector, и количество зависит от сложности приложения.", isCorrect: false },
        { isSelect: false, answer: "Во всем приложении может быть только один Change Detector для каждого компонента.", isCorrect: false },
        { isSelect: false, answer: "Количество Change Detector в приложении зависит от количества компонентов и сервисов и может быть произвольным.", isCorrect: false },
      ],
    },
    {
      question: "Основное отличие constructor от ngOnInit?",
      level: "middle",
      isCompleted: false,
      index: 51,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Constructor - это метод класса, который вызывается при создании экземпляра компонента. В нем обычно выполняется инициализация переменных и настроек, но представление компонента еще не доступно. ngOnInit - это метод жизненного цикла компонента, который вызывается после инициализации всех свойств компонента, включая представление. Основное отличие заключается в том, что в ngOnInit вы можете взаимодействовать с представлением и выполнять дополнительную инициализацию, например, подписку на события.", isCorrect: true },
        { isSelect: false, answer: "Constructor и ngOnInit - это синонимы и выполняют одни и те же задачи.", isCorrect: false },
        { isSelect: false, answer: "Constructor - это метод для создания экземпляра сервиса, а ngOnInit - для компонента.", isCorrect: false },
        { isSelect: false, answer: "Constructor - это метод для создания экземпляра класса, и его использование не рекомендуется в Angular.", isCorrect: false },
      ],
    },
    {
      question: "Для чего нужен RxJS и какую проблему он решает?",
      level: "middle",
      isCompleted: false,
      index: 52,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "RxJS (Reactive Extensions for JavaScript) - это библиотека для работы с асинхронными операциями и управления потоками данных. Она решает проблему работы с асинхронными операциями, такими как HTTP-запросы, события и таймеры, предоставляя мощные инструменты для работы с потоками данных, фильтрации, преобразования и обработки ошибок. RxJS также позволяет создавать реактивные приложения, где изменения в данных автоматически отражаются на представлении.", isCorrect: true },
        { isSelect: false, answer: "RxJS - это библиотека для создания анимаций в Angular и не решает никаких проблем с асинхронными операциями.", isCorrect: false },
        { isSelect: false, answer: "RxJS - это библиотека для работы с синхронными операциями и не имеет отношения к асинхронным задачам.", isCorrect: false },
        { isSelect: false, answer: "RxJS - это библиотека для создания пользовательских элементов интерфейса в Angular.", isCorrect: false },
      ],
    },
    {
      question: "Что такое Observable?",
      level: "middle",
      isCompleted: false,
      index: 53,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Observable - это объект, представляющий асинхронный поток данных, который может испускать значения в течение времени. Он может быть использован для представления событий, HTTP-запросов, таймеров и других асинхронных операций. Observable предоставляет методы для обработки данных, фильтрации, преобразования и управления ошибками в потоке данных.", isCorrect: true },
        { isSelect: false, answer: "Observable - это синхронный объект для представления статических данных, и он не может работать с асинхронными операциями.", isCorrect: false },
        { isSelect: false, answer: "Observable - это встроенный браузерный класс для работы с событиями.", isCorrect: false },
        { isSelect: false, answer: "Observable - это объект для работы с обычными синхронными массивами данных в JavaScript.", isCorrect: false },
      ],
    },
    {
      question: "В чем разница между Observable и Promise?",
      level: "middle",
      isCompleted: false,
      index: 54,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Observable и Promise - это оба механизмы для работы с асинхронными операциями, но есть существенные различия. Основное отличие заключается в том, что Observable позволяет работать с потоками данных, тогда как Promise представляет единичное значение. Observable также поддерживает отмену операций, множественные значения и более мощные методы обработки данных. Promise более прост в использовании, но ограничен по функциональности.", isCorrect: true },
        { isSelect: false, answer: "Observable и Promise - это полностью идентичные механизмы, и нет разницы между ними.", isCorrect: false },
        { isSelect: false, answer: "Observable - это синоним Promise, и они взаимозаменяемы.", isCorrect: false },
        { isSelect: false, answer: "Promise позволяет работать с потоками данных, и Observable представляет единичное значение.", isCorrect: false },
      ],
    },
    {
      question: "В чем разница между Observable и BehaviorSubject/Subject (Higher Order Observables)?",
      level: "middle",
      isCompleted: false,
      index: 55,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Observable - это объект для работы с асинхронными потоками данных. Subject и BehaviorSubject - это специальные типы Observable, которые также позволяют отправлять данные в поток, но они имеют разные особенности. BehaviorSubject хранит последнее значение и предоставляет его новым подписчикам, а Subject не хранит значения. Higher Order Observables - это Observable, который представляет потоки данных в виде Observable.", isCorrect: true },
        { isSelect: false, answer: "Observable, Subject и BehaviorSubject - это полностью идентичные объекты и выполняют одни и те же функции.", isCorrect: false },
        { isSelect: false, answer: "Observable - это синоним Higher Order Observables и может использоваться взаимозаменяемо.", isCorrect: false },
        { isSelect: false, answer: "Observable - это объект для работы с синхронными данными, и он не имеет отношения к асинхронным потокам данных.", isCorrect: false },
      ],
    },
    {
      question: "В чем разница между Subject, BehaviorSubject, ReplaySubject, AsyncSubject?",
      level: "middle",
      isCompleted: false,
      index: 56,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Subject - это простой тип Observable, который позволяет создавать и отправлять данные в поток. BehaviorSubject - это специальный тип Subject, который хранит последнее отправленное значение и предоставляет его новым подписчикам. ReplaySubject - это Subject, который хранит и отправляет несколько последних значений. AsyncSubject - это Subject, который отправляет только последнее значение, после чего завершает поток. Разница заключается в их поведении и спецификации использования.", isCorrect: true },
        { isSelect: false, answer: "Subject, BehaviorSubject, ReplaySubject и AsyncSubject - это полностью идентичные объекты и можно использовать их взаимозаменяемо.", isCorrect: false },
        { isSelect: false, answer: "Subject - это объект для работы с синхронными данными, и он не имеет отношения к Observable.", isCorrect: false },
        { isSelect: false, answer: "BehaviorSubject - это объект для работы с асинхронными потоками данных, и он не имеет отношения к Subject.", isCorrect: false },
      ],
    },
    {
      question: "В чем разница между операторами switchMap, mergeMap, concatMap?",
      level: "middle",
      isCompleted: false,
      index: 57,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "switchMap, mergeMap и concatMap - это операторы для работы с потоками данных в RxJS. Основное отличие между ними заключается в том, как они обрабатывают и объединяют внутренние потоки. switchMap прекращает выполнение предыдущего внутреннего потока, как только появляется новое событие. mergeMap объединяет результаты всех внутренних потоков, независимо от порядка их завершения. concatMap объединяет внутренние потоки в порядке их появления. Разница заключается в стратегии объединения потоков.", isCorrect: true },
        { isSelect: false, answer: "switchMap, mergeMap и concatMap - это полностью идентичные операторы и можно использовать их взаимозаменяемо.", isCorrect: false },
        { isSelect: false, answer: "switchMap, mergeMap и concatMap - это операторы для создания анимаций в Angular и не имеют отношения к RxJS.", isCorrect: false },
        { isSelect: false, answer: "switchMap, mergeMap и concatMap - это операторы для синхронной обработки данных, и они не подходят для работы с асинхронными потоками.", isCorrect: false },
      ],
    },
    {
      question: "Как бы вы кешировали наблюдаемые данные из потоков (stream)?",
      level: "middle",
      isCompleted: false,
      index: 58,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Для кеширования наблюдаемых данных из потоков, можно использовать операторы like 'share', 'shareReplay' и 'publishReplay'. Эти операторы создают общую подписку на источник данных и предоставляют кешированные данные новым подписчикам. Таким образом, данные будут получены из источника только один раз и будут кешированы для последующих подписчиков.", isCorrect: true },
        { isSelect: false, answer: "Кеширование данных из потоков не является возможным, так как потоки всегда создают новые данные при каждой подписке.", isCorrect: false },
        { isSelect: false, answer: "Для кеширования данных следует использовать обычные переменные и не использовать RxJS.", isCorrect: false },
        { isSelect: false, answer: "Кеширование данных из потоков можно выполнить только путем создания кастомных операторов.", isCorrect: false },
      ],
    },
    {
      question: "Что такое Dependency Injection?",
      level: "middle",
      isCompleted: false,
      index: 59,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Dependency Injection - это паттерн внедрения зависимостей, который позволяет предоставлять объектам необходимые зависимости вместо их создания внутри объекта. В Angular, Dependency Injection используется для предоставления сервисов и других зависимостей компонентам и сервисам. Это делает код более гибким, тестируемым и обеспечивает соблюдение принципа единственной ответственности.", isCorrect: true },
        { isSelect: false, answer: "Dependency Injection - это паттерн для создания циклических зависимостей между объектами.", isCorrect: false },
        { isSelect: false, answer: "Dependency Injection - это способ создания экземпляров классов в Angular.", isCorrect: false },
        { isSelect: false, answer: "Dependency Injection - это альтернатива использованию сервисов в Angular.", isCorrect: false },
      ],
    },
    {
      question: "Что такое Singleton Service и с какой целью?",
      level: "middle",
      isCompleted: false,
      index: 60,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Singleton Service - это сервис, который создается только один раз во всем приложении и предоставляет один и тот же экземпляр сервиса для всех компонентов, которые его используют. Основная цель - обеспечить единство данных и состояния в приложении. Это полезно, например, когда необходимо синхронизировать данные между разными компонентами.", isCorrect: true },
        { isSelect: false, answer: "Singleton Service - это сервис, который создается отдельно для каждого компонента, использующего его.", isCorrect: false },
        { isSelect: false, answer: "Singleton Service - это специальный сервис для работы с анимациями в Angular.", isCorrect: false },
        { isSelect: false, answer: "Singleton Service - это сервис, который не может быть использован в Angular приложении.", isCorrect: false },
      ],
    },
    {
      question: "Как можно определить свой обработчик ErrorHandler, Logging, Cache в Angular?",
      level: "middle",
      isCompleted: false,
      index: 61,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Для определения собственных обработчиков ErrorHandler, Logging и Cache в Angular, можно использовать Angular Providers. Создайте сервисы, которые реализуют соответствующий функционал, и зарегистрируйте их в массиве providers в NgModule или на уровне приложения. Например, ErrorHandler может быть зарегистрирован как провайдер для обработки ошибок в приложении.", isCorrect: true },
        { isSelect: false, answer: "Angular предоставляет только встроенные обработчики ErrorHandler, Logging и Cache, и их нельзя заменить собственными.", isCorrect: false },
        { isSelect: false, answer: "Для определения собственных обработчиков ErrorHandler, Logging и Cache в Angular, необходимо внести изменения в исходный код Angular Framework.", isCorrect: false },
        { isSelect: false, answer: "В Angular нельзя определять собственные обработчики ErrorHandler, Logging и Cache.", isCorrect: false },
      ],
    },
    {
      question: "Что такое управление состоянием приложения?",
      level: "middle",
      isCompleted: false,
      index: 62,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Управление состоянием приложения - это паттерн разработки, который предназначен для эффективного управления данными и их состоянием в приложении. В Angular, это может включать в себя использование сторов состояния, как, например, NGRX, NGXS или Akita, для хранения и управления данными в едином месте. Это позволяет приложению иметь одинаковое состояние для всех компонентов и обеспечивает централизованное управление данными.", isCorrect: true },
        { isSelect: false, answer: "Управление состоянием приложения - это способ управления разрешением экрана в Angular.", isCorrect: false },
        { isSelect: false, answer: "Управление состоянием приложения - это процесс управления версиями Angular Framework.", isCorrect: false },
        { isSelect: false, answer: "Управление состоянием приложения - это понятие, которого нет в Angular, и оно не применяется в этом фреймворке.", isCorrect: false },
      ],
    },
    {
      question: "В чем отличие между NGRX, NGXS, Akita и какую проблему они решают?",
      level: "middle",
      isCompleted: false,
      index: 63,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "NGRX, NGXS и Akita - это библиотеки для управления состоянием в Angular-приложениях. Они решают проблему эффективного управления данными и их состоянием. Основные различия между ними заключаются в подходе и синтаксисе. NGRX использует Redux-подобный подход с акшенами и редьюсерами. NGXS предлагает упрощенный синтаксис и интеграцию с Angular Dependency Injection. Akita предлагает минималистичный и декларативный подход. Выбор между ними зависит от потребностей проекта.", isCorrect: true },
        { isSelect: false, answer: "NGRX, NGXS и Akita - это один и тот же пакет для управления состоянием в Angular, и нет разницы между ними.", isCorrect: false },
        { isSelect: false, answer: "NGRX, NGXS и Akita - это библиотеки для создания анимаций в Angular и не решают проблему управления состоянием.", isCorrect: false },
        { isSelect: false, answer: "NGRX, NGXS и Akita - это библиотеки для работы с HTTP-запросами в Angular.", isCorrect: false },
      ],
    },
    {
      question: "Какими способами можно взаимодействовать с API бэкенда, что требуется для проксирования запросов?",
      level: "middle",
      isCompleted: false,
      index: 64,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Для взаимодействия с API бэкенда в Angular, можно использовать HTTP-клиент, который предоставляет возможность отправки HTTP-запросов к серверу. Для проксирования запросов, можно настроить конфигурацию прокси в файле 'proxy.conf.json', который определяет, какие запросы должны быть перенаправлены к API бэкенда. Это позволяет обойти проблему CORS и обеспечить безопасное взаимодействие с сервером.", isCorrect: true },
        { isSelect: false, answer: "В Angular нельзя взаимодействовать с API бэкенда, так как он не поддерживает отправку HTTP-запросов.", isCorrect: false },
        { isSelect: false, answer: "Для взаимодействия с API бэкенда в Angular, нужно реализовать собственный HTTP-клиент с нуля.", isCorrect: false },
        { isSelect: false, answer: "Проксирование запросов не требуется, так как Angular автоматически обеспечивает безопасное взаимодействие с API бэкенда.", isCorrect: false },
      ],
    },
    {
      question: "Что такое HTTP Interceptors?",
      level: "middle",
      isCompleted: false,
      index: 65,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "HTTP Interceptors - это механизм в Angular, который позволяет перехватывать и обрабатывать HTTP-запросы и ответы перед тем, как они достигнут сервера или приложения. Это мощное средство для внедрения логики, такой как добавление заголовков, обработка ошибок, аутентификация и другие аспекты HTTP-взаимодействия. Interceptors регистрируются в приложении и могут быть использованы для различных целей.", isCorrect: true },
        { isSelect: false, answer: "HTTP Interceptors - это часть спецификации HTTP и не имеет отношения к Angular.", isCorrect: false },
        { isSelect: false, answer: "HTTP Interceptors - это специальные сервисы, которые позволяют отправлять HTTP-запросы с сервера к клиенту.", isCorrect: false },
        { isSelect: false, answer: "HTTP Interceptors - это небезопасный механизм и его использование не рекомендуется в Angular.", isCorrect: false },
      ],
    },
    {
      question: "Как использовать Json Web Tokens для аутентификации при разработке на Angular?",
      level: "middle",
      isCompleted: false,
      index: 66,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Для использования JSON Web Tokens (JWT) в аутентификации Angular-приложения, сначала необходимо получить JWT от сервера после успешной аутентификации пользователя. Затем JWT может быть сохранен в локальном хранилище, например, localStorage или sessionStorage. После этого, при каждом запросе к защищенным ресурсам, JWT должен быть включен в заголовки запроса. Angular HTTP Interceptors могут использоваться для автоматической вставки JWT в заголовки. Сервер должен проверить и подтвердить JWT при получении запроса и предоставить доступ к ресурсам, если токен действителен.", isCorrect: true },
        { isSelect: false, answer: "JSON Web Tokens не используются для аутентификации в Angular.", isCorrect: false },
        { isSelect: false, answer: "JWT автоматически включается в каждый HTTP-запрос Angular-приложения без необходимости дополнительной настройки.", isCorrect: false },
        { isSelect: false, answer: "JWT всегда хранится на сервере, и клиент не может им управлять.", isCorrect: false },
      ],
    },
    {
      question: "Как обрабатываются атаки XSS и CSRF в Angular?",
      level: "middle",
      isCompleted: false,
      index: 67,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Angular предоставляет встроенные механизмы для борьбы с атаками XSS (межсайтового скриптинга) и CSRF (межсайтовой подделки запроса). Для защиты от XSS, Angular выполняет автоматическое экранирование данных, вставляемых в шаблоны. Для борьбы с CSRF, Angular включает в запросы специальный токен, который сервер может проверить. Также, рекомендуется использовать Content Security Policy (CSP) и другие меры безопасности.", isCorrect: true },
        { isSelect: false, answer: "Angular не предоставляет механизмов для защиты от атак XSS и CSRF.", isCorrect: false },
        { isSelect: false, answer: "Для защиты от атак XSS и CSRF в Angular необходимо использовать сторонние библиотеки и фреймворки.", isCorrect: false },
        { isSelect: false, answer: "Атаки XSS и CSRF не являются угрозой для Angular-приложений.", isCorrect: false },
      ],
    },
    {
      question: "Что такое роутинг и как его создать в Angular?",
      level: "middle",
      isCompleted: false,
      index: 68,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Роутинг в Angular - это механизм навигации между различными компонентами и представлениями приложения. Для создания роутинга в Angular, необходимо настроить маршруты (Routes), которые связывают URL с компонентами. Это делается с использованием Angular Router. Маршруты определяются в конфигурации роутера и могут включать параметры и дочерние маршруты. Роутер также предоставляет директиву 'router-outlet', которая определяет место в шаблоне, куда будет вставлен компонент, связанный с текущим маршрутом.", isCorrect: true },
        { isSelect: false, answer: "Роутинг - это процесс автоматической генерации URL-адресов в Angular.", isCorrect: false },
        { isSelect: false, answer: "Роутинг - это специальная библиотека для работы с HTTP-запросами в Angular.", isCorrect: false },
        { isSelect: false, answer: "Роутинг - это понятие, которого нет в Angular, и оно не применяется в этом фреймворке.", isCorrect: false },
      ],
    },
    {
      question: "Каков жизненный цикл у Angular Router?",
      level: "middle",
      isCompleted: false,
      index: 69,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Angular Router имеет свой жизненный цикл, который включает в себя этапы и события, такие как активация маршрута, деактивация маршрута, изменение параметров маршрута и другие. Это позволяет отслеживать и реагировать на изменения маршрутов в приложении. Например, можно подписываться на события маршрута для выполнения дополнительных действий при переходе между компонентами.", isCorrect: true },
        { isSelect: false, answer: "Angular Router не имеет собственного жизненного цикла.", isCorrect: false },
        { isSelect: false, answer: "Жизненный цикл Angular Router подобен жизненному циклу Angular компонентов.", isCorrect: false },
        { isSelect: false, answer: "Жизненный цикл Angular Router ограничивается только активацией и деактивацией маршрутов.", isCorrect: false },
      ],
    },
    {
      question: "Что такое ленивая загрузка (Lazy-loading) и для чего она используется?",
      level: "middle",
      isCompleted: false,
      index: 70,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Ленивая загрузка (Lazy-loading) - это подход, который позволяет загружать определенные части приложения только по мере необходимости, вместо загрузки всего приложения сразу. В Angular, ленивая загрузка обычно используется для оптимизации производительности приложения. Это особенно полезно, когда приложение содержит большое количество компонентов или модулей. Ленивая загрузка позволяет разделить приложение на отдельные модули, которые загружаются по требованию, сокращая начальное время загрузки и ускоряя работу приложения.", isCorrect: true },
        { isSelect: false, answer: "Ленивая загрузка - это метод загрузки приложения только во время перезапуска.", isCorrect: false },
        { isSelect: false, answer: "Ленивая загрузка - это способ определения маршрутов в Angular.", isCorrect: false },
        { isSelect: false, answer: "Ленивая загрузка не имеет преимуществ и не используется в Angular.", isCorrect: false },
      ],
    },
    {
      question: "В чем разница между Routing и Navigation?",
      level: "middle",
      isCompleted: false,
      index: 71,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Routing и Navigation - это два связанных, но разных понятия в Angular. Routing относится к определению маршрутов и связыванию их с компонентами приложения. Это позволяет навигировать по приложению, переключаясь между разными представлениями. Navigation, с другой стороны, относится к самому процессу перемещения между маршрутами и компонентами. Он включает в себя навигацию с использованием роутера, переходы между страницами и управление историей браузера.", isCorrect: true },
        { isSelect: false, answer: "Routing и Navigation - это синонимы и используются взаимозаменяемо.", isCorrect: false },
        { isSelect: false, answer: "Routing и Navigation - это одно и то же понятие в Angular.", isCorrect: false },
        { isSelect: false, answer: "Navigation - это процесс создания маршрутов, а Routing - процесс навигации.", isCorrect: false },
      ],
    },
    {
      question: "Как загрузить данные до того как активируется роут?",
      level: "middle",
      isCompleted: false,
      index: 72,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Для загрузки данных до активации маршрута в Angular, можно использовать Angular Resolver. Resolver - это сервис, который предзагружает данные, необходимые для компонента, связанного с маршрутом, до его активации. Resolver подключается к маршруту в его конфигурации и выполняет асинхронный запрос данных. После успешного завершения запроса, маршрут активируется и данные передаются в компонент.", isCorrect: true },
        { isSelect: false, answer: "Данные всегда загружаются после активации маршрута и не могут быть загружены до этого.", isCorrect: false },
        { isSelect: false, answer: "Для загрузки данных до активации маршрута, необходимо использовать Angular Guards.", isCorrect: false },
        { isSelect: false, answer: "Загрузка данных до активации маршрута требует ручной настройки HTTP-запросов в компоненте.", isCorrect: false },
      ],
    },
    {
      question: "Что такое FormGroup и FormControl и для чего они используются?",
      level: "middle",
      isCompleted: false,
      index: 73,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "FormGroup и FormControl - это часть реактивных форм в Angular. FormGroup представляет собой группу контролов (FormControl), которые используются для управления вводом данных в формах. FormControl представляет отдельное поле в форме и содержит значение поля, статус валидации и другие свойства. FormGroup и FormControl используются для создания и управления формами в Angular, включая валидацию, отслеживание изменений и отправку данных на сервер.", isCorrect: true },
        { isSelect: false, answer: "FormGroup и FormControl - это сервисы для работы с HTTP-запросами в Angular.", isCorrect: false },
        { isSelect: false, answer: "FormGroup и FormControl - это устаревшие компоненты, которые не рекомендуется использовать.", isCorrect: false },
        { isSelect: false, answer: "FormGroup и FormControl предназначены только для создания пользовательских контролов и не связаны с формами.", isCorrect: false },
      ],
    },
    {
      question: "Что такое реактивные формы в Angular?",
      level: "middle",
      isCompleted: false,
      index: 74,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Реактивные формы в Angular - это способ создания и управления формами с использованием реактивного программирования. Они позволяют отслеживать состояние формы, валидацию, изменения значений и многое другое с помощью объектов FormGroup и FormControl. Реактивные формы предоставляют более гибкий и мощный способ работы с формами по сравнению с шаблонными формами. Они часто используются для сложных и динамических форм в приложениях.", isCorrect: true },
        { isSelect: false, answer: "Реактивные формы - это альтернативный способ маршрутизации в Angular.", isCorrect: false },
        { isSelect: false, answer: "Реактивные формы - это способ создания анимаций в Angular.", isCorrect: false },
        { isSelect: false, answer: "Реактивные формы - это устаревший метод работы с данными в Angular.", isCorrect: false },
      ],
    },
    {
      question: "Как валидировать формы в Angular?",
      level: "middle",
      isCompleted: false,
      index: 75,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Валидация форм в Angular может быть выполнена с использованием встроенных директив, таких как ngModel, ngModelGroup, и собственных валидаторов. Дополнительно, можно использовать реактивные формы и определять собственные правила валидации с помощью FormControl и FormGroup. Валидация может проверять обязательные поля, формат ввода данных, сравнение значений и другие кастомные правила.", isCorrect: true },
        { isSelect: false, answer: "Валидация форм требует создания кастомных HTTP-запросов в Angular.", isCorrect: false },
        { isSelect: false, answer: "Валидация форм невозможна в Angular.", isCorrect: false },
        { isSelect: false, answer: "Для валидации форм обязательно использовать библиотеки сторонних разработчиков.", isCorrect: false },
      ],
    },
    {
      question: "Как можно кастомизировать встроенные валидаторы?",
      level: "middle",
      isCompleted: false,
      index: 76,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Встроенные валидаторы в Angular могут быть кастомизированы путем создания собственных валидаторов. Это можно сделать путем определения функций-валидаторов и добавления их к FormControl или FormGroup. Эти функции принимают аргументы, такие как управляемое поле формы, и выполняют проверку на соответствие кастомным правилам. Затем результаты проверки возвращаются в виде объекта ошибок, который может быть использован для определения состояния валидации и вывода пользователю сообщений об ошибках.", isCorrect: true },
        { isSelect: false, answer: "Встроенные валидаторы не могут быть кастомизированы в Angular.", isCorrect: false },
        { isSelect: false, answer: "Кастомизация встроенных валидаторов требует редактирования исходного кода Angular.", isCorrect: false },
        { isSelect: false, answer: "Для кастомизации валидаторов необходимо использовать сторонние библиотеки.", isCorrect: false },
      ],
    },
    {
      question: "Что такое DI и как она работает в Angular?",
      level: "middle",
      isCompleted: false,
      index: 77,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "DI (Dependency Injection) - это механизм, который позволяет внедрять зависимости в компоненты и сервисы Angular. DI позволяет создавать и управлять экземплярами зависимых объектов, обеспечивая многократное использование и упрощая тестирование. В Angular, DI работает следующим образом: при создании компонента или сервиса, фреймворк автоматически ищет или создает экземпляры всех необходимых зависимостей и передает их в конструкторы. Это делает код более модульным и легким для тестирования.", isCorrect: true },
        { isSelect: false, answer: "DI - это обратный механизм в Angular, который удаляет зависимости из компонентов.", isCorrect: false },
        { isSelect: false, answer: "DI - это библиотека стороннего разработчика для внедрения зависимостей в Angular.", isCorrect: false },
        { isSelect: false, answer: "DI - это механизм для создания динамических интерфейсов в Angular.", isCorrect: false },
      ],
    },
    {
      question: "Как работают директивы ngIf, ngFor?",
      level: "middle",
      isCompleted: false,
      index: 78,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Директива ngIf используется для условного отображения элемента на основе значения выражения. Если выражение истинное, элемент отображается, иначе он скрывается. Директива ngFor используется для создания повторяющегося списка элементов на основе массива или коллекции. Она создает отдельный элемент для каждого элемента в коллекции. Обе директивы являются структурными и могут изменять структуру DOM в зависимости от данных.", isCorrect: true },
        { isSelect: false, answer: "Директивы ngIf и ngFor используются для создания анимаций в Angular.", isCorrect: false },
        { isSelect: false, answer: "Директивы ngIf и ngFor используются для маршрутизации в Angular.", isCorrect: false },
        { isSelect: false, answer: "Директивы ngIf и ngFor используются для создания кастомных атрибутов в Angular.", isCorrect: false },
      ],
    },
    {
      question: "Что такое content projection (проекция содержимого) и как использовать ng-content?",
      level: "middle",
      isCompleted: false,
      index: 79,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Content projection - это механизм, который позволяет встраивать контент внутрь компонентов в Angular. Для использования ng-content, в компоненте определяется место, где контент будет вставлен с помощью <ng-content></ng-content>. Затем при использовании компонента в шаблоне, контент, размещенный внутри его тега, будет вставлен в это место. Это позволяет создавать более гибкие и переиспользуемые компоненты, которые могут включать пользовательский контент.", isCorrect: true },
        { isSelect: false, answer: "Content projection - это механизм для создания анимаций в Angular.", isCorrect: false },
        { isSelect: false, answer: "Content projection - это механизм для маршрутизации в Angular.", isCorrect: false },
        { isSelect: false, answer: "Content projection - это механизм для создания атрибутов в Angular.", isCorrect: false },
      ],
    },
    {
      question: "Как создать собственный атрибутную директиву и зачем она нужна?",
      level: "middle",
      isCompleted: false,
      index: 80,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Для создания собственной атрибутной директивы в Angular, необходимо создать класс, который реализует интерфейс Directive, и применить декоратор @Directive к этому классу. Затем можно определить собственные атрибуты и логику, связанную с этой директивой. Атрибутные директивы используются для изменения внешнего вида или поведения элементов DOM. Они могут быть полезны, например, для создания кастомных стилей или валидации полей формы.", isCorrect: true },
        { isSelect: false, answer: "Создание атрибутных директив в Angular запрещено.", isCorrect: false },
        { isSelect: false, answer: "Для создания атрибутных директив обязательно требуется использование сторонних библиотек.", isCorrect: false },
        { isSelect: false, answer: "Атрибутные директивы используются только для создания анимаций в Angular.", isCorrect: false },
      ],
    },
    {
      question: "Что такое Input и Output свойства в компонентах?",
      level: "middle",
      isCompleted: false,
      index: 81,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Input и Output свойства - это специальные декораторы, которые используются для установки взаимодействия между родительским и дочерним компонентами в Angular. @Input используется для передачи данных от родительского компонента в дочерний, а @Output используется для передачи событий от дочернего компонента в родительский. Это позволяет создавать более гибкие и переиспользуемые компоненты.", isCorrect: true },
        { isSelect: false, answer: "Input и Output свойства - это специальные директивы для стилизации компонентов.", isCorrect: false },
        { isSelect: false, answer: "Input и Output свойства - это специальные декораторы для создания анимаций в Angular.", isCorrect: false },
        { isSelect: false, answer: "Input и Output свойства - это специальные декораторы для маршрутизации в Angular.", isCorrect: false },
      ],
    },
    {
      question: "Что такое Template Reference Variables?",
      level: "middle",
      isCompleted: false,
      index: 82,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Template Reference Variables - это специальные переменные, которые позволяют ссылаться на элементы DOM или компоненты в шаблоне Angular. Они создаются с помощью символа # и имени переменной. Эти переменные могут использоваться для доступа к данным и методам элементов DOM или компонентов в шаблоне, что делает их более доступными и удобными для манипуляции.", isCorrect: true },
        { isSelect: false, answer: "Template Reference Variables - это переменные, которые используются только в TypeScript коде компонента.", isCorrect: false },
        { isSelect: false, answer: "Template Reference Variables - это переменные, которые не могут быть использованы в Angular приложениях.", isCorrect: false },
        { isSelect: false, answer: "Template Reference Variables - это переменные, созданные только для стилизации компонентов.", isCorrect: false },
      ],
    },
    {
      question: "Как работают структурные директивы (ngIf, ngFor)?",
      level: "middle",
      isCompleted: false,
      index: 83,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Структурные директивы, такие как ngIf и ngFor, позволяют изменять структуру DOM в зависимости от условий или данных. Например, ngIf скрывает или отображает элемент в зависимости от значения выражения, а ngFor создает повторяющиеся элементы на основе коллекции. Они работают путем добавления или удаления элементов из DOM, в зависимости от условий, и делают шаблоны более динамичными и гибкими.", isCorrect: true },
        { isSelect: false, answer: "Структурные директивы не могут изменять структуру DOM в Angular.", isCorrect: false },
        { isSelect: false, answer: "Структурные директивы используются только для создания анимаций в Angular.", isCorrect: false },
        { isSelect: false, answer: "Структурные директивы используются только для маршрутизации в Angular.", isCorrect: false },
      ],
    },
    {
      question: "Как создать собственную структурную директиву?",
      level: "middle",
      isCompleted: false,
      index: 84,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Для создания собственной структурной директивы в Angular, необходимо создать класс, который реализует интерфейс `NgStructuralDirective` и применить декоратор @Directive с аргументом 'ngFor', 'ngIf' и т. д. Затем можно определить собственную логику, связанную с тем, как директива должна изменять структуру DOM. Структурные директивы позволяют создавать кастомные поведения в шаблонах.", isCorrect: true },
        { isSelect: false, answer: "Создание собственных структурных директив в Angular запрещено.", isCorrect: false },
        { isSelect: false, answer: "Для создания собственных структурных директив обязательно требуется использование сторонних библиотек.", isCorrect: false },
        { isSelect: false, answer: "Структурные директивы не могут быть кастомизированы.", isCorrect: false },
      ],
    },
    {
      question: "Что такое компоненты и зачем они нужны в Angular?",
      level: "middle",
      isCompleted: false,
      index: 85,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Компоненты - это основные строительные блоки пользовательского интерфейса в Angular. Они представляют собой независимые, переиспользуемые части приложения, которые включают в себя шаблон (HTML), стили (CSS) и код (TypeScript). Компоненты используются для организации и разделения функциональности приложения на логические части, что делает код более читаемым и управляемым.", isCorrect: true },
        { isSelect: false, answer: "Компоненты - это специальные директивы для стилизации элементов DOM.", isCorrect: false },
        { isSelect: false, answer: "Компоненты - это специальные декораторы для создания анимаций в Angular.", isCorrect: false },
        { isSelect: false, answer: "Компоненты - это специальные декораторы для маршрутизации в Angular.", isCorrect: false },
      ],
    },
    {
      question: "Какие бывают жизненные хуки у компонентов?",
      level: "middle",
      isCompleted: false,
      index: 86,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "У компонентов в Angular есть несколько жизненных циклов, называемых хуками. Основные жизненные хуки включают ngOnInit, ngOnDestroy, ngOnChanges, ngAfterViewInit и другие. ngOnInit вызывается после инициализации компонента, ngOnDestroy вызывается перед уничтожением компонента, ngOnChanges вызывается при изменении входных данных и так далее. Жизненные хуки позволяют выполнять действия на разных этапах жизни компонента.", isCorrect: true },
        { isSelect: false, answer: "Компоненты в Angular не имеют жизненных хуков.", isCorrect: false },
        { isSelect: false, answer: "Жизненные хуки используются только в сервисах Angular.", isCorrect: false },
        { isSelect: false, answer: "Жизненные хуки предназначены только для структурных директив в Angular.", isCorrect: false },
      ],
    },
    {
      question: "Что такое динамические компоненты в Angular?",
      level: "middle",
      isCompleted: false,
      index: 87,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Динамические компоненты в Angular - это способ создания и рендеринга компонентов во время выполнения приложения. Они позволяют динамически добавлять, удалять или изменять компоненты на основе данных или событий. Для создания динамических компонентов используются фабрики компонентов и компонентный резольвер. Это полезно, например, при создании модальных окон, динамических форм и других динамических интерфейсов.", isCorrect: true },
        { isSelect: false, answer: "Динамические компоненты - это компоненты, которые создаются только во время компиляции приложения.", isCorrect: false },
        { isSelect: false, answer: "Динамические компоненты - это структурные директивы в Angular.", isCorrect: false },
        { isSelect: false, answer: "Динамические компоненты не поддерживаются в Angular.", isCorrect: false },
      ],
    },
    {
      question: "Как обновить компонент при изменении данных, полученных из сервиса?",
      level: "middle",
      isCompleted: false,
      index: 88,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Для обновления компонента при изменении данных, полученных из сервиса, можно использовать RxJS и подписываться на поток данных, возвращаемый сервисом. Когда данные изменяются, компонент автоматически обновится. Это может быть выполнено с использованием операторов, таких как subscribe, async pipe и других операторов RxJS.", isCorrect: true },
        { isSelect: false, answer: "Обновление компонента при изменении данных требует ручного обновления компонента в каждом случае.", isCorrect: false },
        { isSelect: false, answer: "Для обновления компонента нужно перезагружать всю страницу.", isCorrect: false },
        { isSelect: false, answer: "Данные не могут быть обновлены в компоненте после их получения.", isCorrect: false },
      ],
    },
    {
      question: "Что такое Angular CLI и как им пользоваться?",
      level: "middle",
      isCompleted: false,
      index: 89,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Angular CLI (Command Line Interface) - это инструмент командной строки, предоставляемый Angular для упрощения разработки приложений. С его помощью можно быстро создавать компоненты, модули, сервисы, запускать локальный сервер разработки, собирать приложение для развертывания и многое другое. Для использования Angular CLI необходимо установить его глобально и выполнять команды через терминал.", isCorrect: true },
        { isSelect: false, answer: "Angular CLI - это графический редактор для создания компонентов.", isCorrect: false },
        { isSelect: false, answer: "Angular CLI - это часть Angular, и его использование не требует установки.", isCorrect: false },
        { isSelect: false, answer: "Angular CLI - это библиотека для работы с базами данных в Angular.", isCorrect: false },
      ],
    },
    {
      question: "Как создать собственный CLI генератор?",
      level: "middle",
      isCompleted: false,
      index: 90,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Создание собственного CLI генератора в Angular - это возможность расширения функциональности Angular CLI с помощью собственных генераторов кода. Для этого нужно создать собственный NPM-пакет, который содержит генераторы и метаданные. Этот пакет можно зарегистрировать глобально, и Angular CLI будет в состоянии использовать ваши собственные генераторы через команды, подобные 'ng generate'. Это полезно, чтобы стандартизировать шаблоны кода в вашей команде разработчиков.", isCorrect: true },
        { isSelect: false, answer: "Создание собственного CLI генератора в Angular требует редактирования исходного кода Angular CLI.", isCorrect: false },
        { isSelect: false, answer: "Собственные CLI генераторы не поддерживаются в Angular.", isCorrect: false },
        { isSelect: false, answer: "Создание собственного CLI генератора возможно только в старых версиях Angular.", isCorrect: false },
      ],
    },
    {
      question: "Что такое E2E-тестирование, какие инструменты вы знаете?",
      level: "middle",
      isCompleted: false,
      index: 91,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "E2E-тестирование (end-to-end testing) - это метод тестирования программного обеспечения, в котором проверяется работа приложения как единого целого, включая пользовательский интерфейс, бэкенд, базу данных и другие компоненты. Эти тесты моделируют действия реальных пользователей. Для E2E-тестирования Angular-приложений часто используются инструменты, такие как Protractor, Cypress, TestCafe и другие.", isCorrect: true },
        { isSelect: false, answer: "E2E-тестирование - это тестирование только пользовательского интерфейса без учета бэкенда и других компонентов.", isCorrect: false },
        { isSelect: false, answer: "E2E-тестирование - это тестирование только бэкенда приложения.", isCorrect: false },
        { isSelect: false, answer: "E2E-тестирование - это метод тестирования, не используемый в разработке Angular-приложений.", isCorrect: false },
      ],
    },
    {
      question: "Как создать тестовое окружение для Angular приложения?",
      level: "middle",
      isCompleted: false,
      index: 92,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Для создания тестового окружения для Angular приложения можно использовать фреймворк для тестирования, такой как Jasmine или Jest, а также инструменты Angular Testing, включая TestBed и ComponentFixture. Тестовое окружение позволяет создавать и запускать юнит-тесты и интеграционные тесты для компонентов, сервисов и других частей Angular-приложения.", isCorrect: true },
        { isSelect: false, answer: "Тестовое окружение для Angular приложения создается автоматически и не требует дополнительных настроек.", isCorrect: false },
        { isSelect: false, answer: "Тестовое окружение создается только для E2E-тестирования, а не для юнит-тестов.", isCorrect: false },
        { isSelect: false, answer: "Для создания тестового окружения используется отдельное приложение, отличное от основного Angular-приложения.", isCorrect: false },
      ],
    },
    {
      question: "Что такое TSLint и ESLint, какую проблему они решают?",
      level: "middle",
      isCompleted: false,
      index: 93,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "TSLint и ESLint - это инструменты статического анализа кода, которые используются для выявления и исправления потенциальных проблем в JavaScript и TypeScript коде. Они проверяют код на соответствие стандартам оформления, наличие ошибок, дублирование кода и другие проблемы. TSLint применяется к TypeScript, а ESLint - к JavaScript. Они помогают улучшить качество и поддерживаемость кода.", isCorrect: true },
        { isSelect: false, answer: "TSLint и ESLint - это библиотеки для тестирования Angular-приложений.", isCorrect: false },
        { isSelect: false, answer: "TSLint и ESLint - это инструменты для создания анимаций в Angular.", isCorrect: false },
        { isSelect: false, answer: "TSLint и ESLint - это фреймворки для разработки игр.", isCorrect: false },
      ],
    },
    {
      question: "Какими инструментами вы пользуетесь для тестирования кода?",
      level: "middle",
      isCompleted: false,
      index: 94,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Для тестирования кода в Angular-приложениях часто используются Jasmine или Jest для юнит-тестирования, а также инструменты E2E-тестирования, такие как Protractor или Cypress. Кроме того, инструменты статического анализа кода, такие как TSLint и ESLint, помогают выявить потенциальные проблемы. Для непрерывной интеграции (CI) и непрерывной поставки (CD) могут применяться инструменты, такие как Jenkins, Travis CI или CircleCI.", isCorrect: true },
        { isSelect: false, answer: "Для тестирования кода в Angular не требуются дополнительные инструменты.", isCorrect: false },
        { isSelect: false, answer: "Используются только инструменты для E2E-тестирования, такие как Protractor.", isCorrect: false },
        { isSelect: false, answer: "Используются только инструменты для статического анализа кода, такие как TSLint.", isCorrect: false },
      ],
    },
    {
      question: "Как работают Preprocessors в CSS (Sass, Less, Scss), зачем они нужны?",
      level: "middle",
      isCompleted: false,
      index: 95,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Preprocessors в CSS, такие как Sass, Less и Scss, представляют собой языки, которые расширяют стандартный CSS и добавляют дополнительные функции, такие как переменные, миксины, вложенные правила и другие. Они позволяют улучшить организацию и поддерживаемость CSS-кода, а также уменьшить его объем. Препроцессоры компилируются в обычный CSS перед развертыванием на веб-сервере.", isCorrect: true },
        { isSelect: false, answer: "Preprocessors в CSS используются только для создания анимаций.", isCorrect: false },
        { isSelect: false, answer: "Preprocessors в CSS не предоставляют никаких дополнительных функций и не улучшают организацию CSS-кода.", isCorrect: false },
        { isSelect: false, answer: "Preprocessors в CSS заменяют стандартный CSS и не требуют компиляции.", isCorrect: false },
      ],
    },
    {
      question: "Как работать с анимациями в CSS, когда их нужно использовать?",
      level: "middle",
      isCompleted: false,
      index: 96,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Анимации в CSS позволяют создавать плавные и привлекательные переходы и эффекты на веб-страницах. Для работы с анимациями в CSS, вы можете использовать ключевые кадры (CSS keyframes), переходы (transitions), и анимации (animations). Анимации могут быть полезными, когда необходимо добавить визуальные эффекты, такие как плавные появления, перемещения и изменения размеров элементов. Они могут использоваться, чтобы улучшить пользовательский опыт и сделать веб-приложение более интерактивным.", isCorrect: true },
        { isSelect: false, answer: "Анимации в CSS используются только для создания сложных математических графиков.", isCorrect: false },
        { isSelect: false, answer: "Анимации в CSS не имеют практического применения и не используются в веб-разработке.", isCorrect: false },
        { isSelect: false, answer: "Анимации в CSS подходят только для текстовых элементов, но не для изображений.", isCorrect: false },
      ],
    },
    {
      question: "Какие инструменты вы используете для управления состоянием в приложении?",
      level: "middle",
      isCompleted: false,
      index: 97,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Для управления состоянием в приложении Angular часто используются библиотеки и паттерны, такие как NGRX, NGXS, Akita. Эти инструменты предоставляют механизмы для управления данными и состоянием приложения, особенно когда речь идет о приложениях с большим объемом данных и сложной логикой. Они позволяют управлять состоянием приложения и обеспечивать однозначность данных в приложении.", isCorrect: true },
        { isSelect: false, answer: "Для управления состоянием в Angular приложениях используются только стандартные средства, предоставляемые фреймворком Angular.", isCorrect: false },
        { isSelect: false, answer: "Управление состоянием не требуется в Angular приложениях.", isCorrect: false },
        { isSelect: false, answer: "Для управления состоянием используются только серверные базы данных.", isCorrect: false },
      ],
    },
    {
      question: "Что такое Webpack и как его настроить для Angular?",
      level: "middle",
      isCompleted: false,
      index: 98,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Webpack - это инструмент для сборки (bundling) и управления зависимостями в веб-приложениях. Для настройки Webpack в Angular-приложении, вы можете использовать файлы конфигурации webpack.config.js или angular.json. В них определяются правила для сборки кода, загрузчики (loaders), и плагины (plugins) для оптимизации и минификации кода. Webpack позволяет создавать оптимизированные бандлы из TypeScript, JavaScript, CSS и других ресурсов, что повышает производительность приложения.", isCorrect: true },
        { isSelect: false, answer: "Webpack - это среда разработки для Angular, которая не требует дополнительной настройки.", isCorrect: false },
        { isSelect: false, answer: "Настройка Webpack не требуется в Angular, так как фреймворк Angular включает в себя средства сборки.", isCorrect: false },
        { isSelect: false, answer: "Webpack используется только для создания серверов в Angular.", isCorrect: false },
      ],
    },
    {
      question: "Как работают анимации в Angular?",
      level: "middle",
      isCompleted: false,
      index: 99,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Анимации в Angular позволяют создавать плавные и интерактивные анимации внутри Angular-приложения. Для создания анимаций в Angular используется Angular Animation API, который предоставляет набор инструментов и функций для определения анимаций и их поведения. Вы можете определять анимации для различных событий, таких как вход и выход элемента, изменение его состояния и т. д. Анимации могут включать в себя перемещения, изменения размеров, плавные переходы и другие эффекты.", isCorrect: true },
        { isSelect: false, answer: "Анимации в Angular создаются с помощью стандартных CSS анимаций.", isCorrect: false },
        { isSelect: false, answer: "Анимации в Angular не поддерживаются и не могут быть использованы в приложениях.", isCorrect: false },
        { isSelect: false, answer: "Анимации в Angular используются только для текстовых элементов.", isCorrect: false },
      ],
    },
    {
      question: "Какие инструменты вы используете для документации кода?",
      level: "middle",
      isCompleted: false,
      index: 100,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Для документации кода в Angular-приложениях часто используются инструменты, такие как Compodoc, TypeDoc и JSDoc. Compodoc предназначен для документации Angular-кода и генерации красочных HTML-страниц с описанием компонентов, сервисов и модулей. TypeDoc используется для генерации документации по TypeScript-коду. JSDoc позволяет добавлять комментарии и аннотации к JavaScript-коду, которые могут быть использованы инструментами автодокументации.", isCorrect: true },
        { isSelect: false, answer: "Для документации кода используются только ручные методы, такие как создание текстовых документов.", isCorrect: false },
        { isSelect: false, answer: "Документация кода не требуется в Angular-приложениях.", isCorrect: false },
        { isSelect: false, answer: "Для документации кода используется только специализированное программное обеспечение.", isCorrect: false },
      ],
    },
    {
      question: "Что такое Web Workers и для чего они используются в Angular?",
      level: "middle",
      isCompleted: false,
      index: 101,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Web Workers - это механизм в браузерах, который позволяет выполнять JavaScript-код в отдельных потоках, не блокируя основной поток браузера. Они используются в Angular и других веб-приложениях для выполнения вычислительно интенсивных задач, обработки данных, а также для обеспечения многозадачности в веб-приложениях. Web Workers могут улучшить производительность приложения, так как позволяют выполнять задачи параллельно.", isCorrect: true },
        { isSelect: false, answer: "Web Workers - это часть Angular, отвечающая за обработку HTTP-запросов.", isCorrect: false },
        { isSelect: false, answer: "Web Workers - это специализированные библиотеки для создания веб-приложений.", isCorrect: false },
        { isSelect: false, answer: "Web Workers используются только для анимаций в Angular.", isCorrect: false },
      ],
    },
    {
      question: "Какие бывают проблемы при разработке на Angular и как их решать?",
      level: "middle",
      isCompleted: false,
      index: 102,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "При разработке на Angular могут возникнуть проблемы, такие как производительность приложения, сложность кода, управление состоянием, тестирование и другие. Проблемы можно решать путем использования лучших практик и паттернов разработки, таких как ленивая загрузка модулей, использование состояния приложения с помощью библиотек NGRX, NGXS или Akita, написание тестов, оптимизация кода, а также следование принципам реактивного программирования с использованием RxJS.", isCorrect: true },
        { isSelect: false, answer: "При разработке на Angular не возникает никаких проблем.", isCorrect: false },
        { isSelect: false, answer: "Проблемы при разработке на Angular невозможно решить.", isCorrect: false },
        { isSelect: false, answer: "Проблемы решаются только с помощью дополнительных библиотек и инструментов.", isCorrect: false },
      ],
    },
    {
      question: "Какие лучшие практики вы можете порекомендовать при работе с Angular?",
      level: "middle",
      isCompleted: false,
      index: 103,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "При работе с Angular рекомендуется следовать лучшим практикам, таким как использование ленивой загрузки модулей для оптимизации производительности, применение реактивного программирования с RxJS, использование NGRX, NGXS или Akita для управления состоянием, написание модульных и чистых компонентов, тестирование кода с использованием фреймворка для тестирования, такого как Jasmine и Karma, а также документирование кода и его структуры.", isCorrect: true },
        { isSelect: false, answer: "Лучшие практики не имеют значения в разработке на Angular.", isCorrect: false },
        { isSelect: false, answer: "Лучшие практики отличаются для каждого проекта и разработчика.", isCorrect: false },
        { isSelect: false, answer: "Лучшие практики не существуют, и каждый разработчик вольнолюбит решать задачи по-своему.", isCorrect: false },
      ],
    },
    {
      question: "Что такое и как работает Service Worker в Angular?",
      level: "middle",
      isCompleted: false,
      index: 104,
      isCorrectAnswer: false,
      links: [],
      answers: [
        { isSelect: false, answer: "Service Worker - это скрипт, который работает в фоновом режиме в браузере и позволяет обрабатывать события сети, такие как запросы HTTP. В Angular, Service Worker используется для создания прогрессивных веб-приложений (PWA), которые могут работать в офлайн-режиме, кэшировать ресурсы и улучшать производительность. Service Worker можно настроить для кэширования статических и динамических ресурсов приложения, а также для уведомлений и фоновой синхронизации данных.", isCorrect: true },
        { isSelect: false, answer: "Service Worker - это специализированный сервис для разработки Angular-приложений.", isCorrect: false },
        { isSelect: false, answer: "Service Worker используется только для обработки событий сети.", isCorrect: false },
        { isSelect: false, answer: "Service Worker не имеет отношения к разработке Angular-приложений.", isCorrect: false },
      ],
    },
  ];

  getArrayQuestions(): QuestionI[] {
    let data: QuestionI[] = this.data;
    const localStorageData = JSON.parse(JSON.stringify(localStorage.getItem('questions')));
    console.log('localStorageData: ', localStorageData);
    if (localStorageData) data = localStorageData
    console.log('data: ', data);
    return this.data
  }

  getQuestionById(id: number): QuestionI | null {
    const question = this.data.find(item => item.index === id)
    if (question) return question
    else return null
  }

  setQuestionData(data: QuestionI[]): void {
    console.log('this.data: ', this.data);
    localStorage.setItem('questions', JSON.stringify(data))
  }

  getQuestions(): void {
    const uid = this.authService.localId
    this.http.get<any>(`${environment.firebaseConfig.databaseURL}/questions/${uid}.json`).subscribe(response => {
      console.log('response: ', response);
      const transformedData = this.transformData(response);
      console.log('transformedData: ', transformedData);
      this.questionsData$.next(transformedData)
    })
  }

  transformData(data: any): QuestionI[] {
    return Object.keys(data).map((key) => {
      return { ...data[key], key: key, };
    });
  }

  addQuestion(item: any): Observable<any> {
    const uid = this.authService.localId
    const route = `${environment.firebaseConfig.databaseURL}/questions/${uid}.json`
    return this.http.post<any>(route, item)
  }

  updateQuestion(key: string, updatedData: any): Observable<any> {
    const uid = this.authService.localId;
    const route = `${environment.firebaseConfig.databaseURL}/questions/${uid}/${key}.json`;
    return this.http.patch(route, updatedData);
  }
}
